<p>接上篇文章，我们在实现了 APlayer 的 Tree-Shaking 之后，遇到了一个新的问题：我们成功为播放器的某些功能拆分出了对应的插件，通过 <code>APlayer.use(plugin)</code> 的方式进行加载。但是有的插件会为 <code>APlayer</code> 注入新的方法，我们希望在加载插件后能够正确的提示出这些方法；并且在不加载插件的时候，不会提示出这些方法。即，<code>use</code> 操作需要返回一个新的 <code>APlayer</code> 类型，这个类型包含了插件注入的方法。</p>
<p>本文先介绍一下这个功能的实现，然后再讨论一下 TypeScript 中的 <code>unknown</code>, <code>never</code>, <code>void</code> 和 <code>any</code> 等特殊类型。</p>
<p>参考：</p>
<ul>
<li>（推荐阅读）简单科普底类型（Bottom Type）、单元类型（Unit Type）以及顶类型（Top Type）：<a href="https://zhuanlan.zhihu.com/p/677605002" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/677605002</a></li>
<li>（官方）TypeScript: Type Compatibility：<a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html#any-unknown-object-void-undefined-null-and-never-assignability" target="_blank" rel="noopener">https://www.typescriptlang.org/docs/handbook/type-compatibility.html#any-unknown-object-void-undefined-null-and-never-assignability</a></li>
</ul>
<!-- more -->
<h2 id="%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0" tabindex="-1">功能实现</h2>
<p>首先，插件是一个接收 <code>APlayer</code> 类型的参数的函数，它会在 <code>APlayer</code> 上注入一些新的方法。我们可以通过 TypeScript 的泛型来表示这个插件：</p>
<pre class="shiki shiki-themes vitesse-light vitesse-dark" style="background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee" tabindex="0"><code class="language-typescript"><span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> Plugin</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">P</span><span style="color:#999999;--shiki-dark:#666666">></span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#999999;--shiki-dark:#666666"> (</span><span style="color:#B07D48;--shiki-dark:#BD976A">player</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">APlayer</span><span style="color:#999999;--shiki-dark:#666666">)</span><span style="color:#999999;--shiki-dark:#666666"> =></span><span style="color:#2E8F82;--shiki-dark:#5DA994"> void</span><span style="color:#999999;--shiki-dark:#666666">;</span></span>
<span class="line"><span style="color:#1E754F;--shiki-dark:#4D9375">export</span><span style="color:#AB5959;--shiki-dark:#CB7676"> const </span><span style="color:#B07D48;--shiki-dark:#BD976A">APlayerFixedModePlugin</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">Plugin</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">unknown</span><span style="color:#999999;--shiki-dark:#666666">>;</span></span>
<span class="line"><span style="color:#1E754F;--shiki-dark:#4D9375">export</span><span style="color:#AB5959;--shiki-dark:#CB7676"> const </span><span style="color:#B07D48;--shiki-dark:#BD976A">APlayerHlsPlugin</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">Plugin</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">unknown</span><span style="color:#999999;--shiki-dark:#666666">>;</span></span>
<span class="line"><span style="color:#1E754F;--shiki-dark:#4D9375">export</span><span style="color:#AB5959;--shiki-dark:#CB7676"> const </span><span style="color:#B07D48;--shiki-dark:#BD976A">addMusicPlugin</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">Plugin</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;{</span></span>
<span class="line"><span style="color:#B07D48;--shiki-dark:#BD976A">  list</span><span style="color:#999999;--shiki-dark:#666666">: {</span></span>
<span class="line"><span style="color:#59873A;--shiki-dark:#80A665">    add</span><span style="color:#999999;--shiki-dark:#666666">: (</span><span style="color:#B07D48;--shiki-dark:#BD976A">audios</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">Audio</span><span style="color:#999999;--shiki-dark:#666666">[] | </span><span style="color:#2E8F82;--shiki-dark:#5DA994">Audio</span><span style="color:#999999;--shiki-dark:#666666">) => </span><span style="color:#2E8F82;--shiki-dark:#5DA994">void</span><span style="color:#999999;--shiki-dark:#666666">;</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">  }</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">}>;</span></span></code></pre>
<p>不难想到 <code>APlayer</code> 类型也应该是一个泛型：</p>
<pre class="shiki shiki-themes vitesse-light vitesse-dark" style="background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee" tabindex="0"><code class="language-typescript"><span class="line"><span style="color:#1E754F;--shiki-dark:#4D9375">export</span><span style="color:#AB5959;--shiki-dark:#CB7676"> type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> APlayer</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> unknown</span><span style="color:#999999;--shiki-dark:#666666">></span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#999999;--shiki-dark:#666666"> {</span></span>
<span class="line"><span style="color:#59873A;--shiki-dark:#80A665">  init</span><span style="color:#999999;--shiki-dark:#666666">(</span><span style="color:#B07D48;--shiki-dark:#BD976A">options</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">APlayerOptions</span><span style="color:#999999;--shiki-dark:#666666">):</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> APlayer</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">>;</span></span>
<span class="line"><span style="color:#59873A;--shiki-dark:#80A665">  use</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">P</span><span style="color:#999999;--shiki-dark:#666666">>(</span><span style="color:#B07D48;--shiki-dark:#BD976A">plugin</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">Plugin</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">P</span><span style="color:#999999;--shiki-dark:#666666">>):</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> APlayer</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666"> &#x26;</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> P</span><span style="color:#999999;--shiki-dark:#666666">>;</span></span>
<span class="line"><span style="color:#59873A;--shiki-dark:#80A665">  play</span><span style="color:#999999;--shiki-dark:#666666">():</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> void</span><span style="color:#999999;--shiki-dark:#666666">;</span></span>
<span class="line"><span style="color:#A0ADA0;--shiki-dark:#758575DD">  // ... other methods</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">}</span><span style="color:#999999;--shiki-dark:#666666"> &#x26;</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> T</span></span></code></pre>
<p>每次 <code>use</code> 操作都将插件提供的类型 <code>P</code> 与当前 <code>APlayer</code> 的泛型参数 <code>T</code> 进行合并。通过 <code>APlayer&lt;T&gt; = {...} &amp; T</code> 的方式，我们将 <code>APlayer</code> 自带方法的类型与插件提供方法的类型进行了合并。</p>
<p>这里功能已经实现了，但还遗留了一些问题：</p>
<ul>
<li>这里泛型的默认值为什么选择了 <code>unknown</code>？</li>
<li><code>APlayer</code> 的泛型参数 <code>T</code> 与 <code>P</code> 的合并操作是什么意思？</li>
</ul>
<p>后文继续讨论。</p>
<h2 id="typescript-%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E2%80%9C%E7%A9%BA%E2%80%9D%E7%B1%BB%E5%9E%8B" tabindex="-1">TypeScript 中的特殊“空”类型</h2>
<h3 id="%E6%A6%82%E5%BF%B5%EF%BC%9Aanyscript" tabindex="-1">概念：AnyScript</h3>
<p>相信大家都看过那张 JavaScript 的各种 falsy 值相互之间是否 <code>==</code> 相等的表格 meme，现在 TypeScript 出现了，“空”类型更多了（x</p>
<p>先明确一些重要的概念：</p>
<ul>
<li>子类型几乎可以看成是一种 <code>assignable to</code> 的关系，即 <code>A</code> 是 <code>B</code> 的子类型几乎等价任何需要 <code>B</code> 类型值的地方都可以使用 <code>A</code> 类型的值。</li>
<li><code>any</code> 类型是特例，可以赋值给任何类型（除 <code>never</code>）或者被任何类型赋值。相当于 TypeScript 开的一个后门，后文不再考虑。</li>
</ul>
<p>嘛，毕竟赋值/隐式类型转换就是我们最常见的操作。在不考虑 <code>any</code> 之后，子类型关系就形成了一个链条，如果 <code>A</code> 是 <code>B</code> 的子类型，<code>B</code> 是 <code>C</code> 的子类型，那么 <code>A</code> 也是 <code>C</code> 的子类型。这种关系叫做偏序关系。</p>
<h3 id="%E7%B1%BB%E5%9E%8B%E5%8D%B3%E9%9B%86%E5%90%88" tabindex="-1">类型即集合</h3>
<p>我们可以进一步形式化这一偏序关系：</p>
<ul>
<li>考虑每个类型都对应一个由它的所有可取值组成的集合，那么 <code>A</code> 是 <code>B</code> 的子类型，就意味着 <code>A</code> 的集合是 <code>B</code> 的集合的子集。
<ul>
<li>这等价于 <code>assignable to</code> 关系成立。</li>
</ul>
</li>
<li>类型的 Intersection 和 Union 操作，就是对应可取值集合的交和并操作。</li>
</ul>
<p>听起来还是有点抽象，我们举几个例子：</p>
<pre class="shiki shiki-themes vitesse-light vitesse-dark" style="background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee" tabindex="0"><code class="language-typescript"><span class="line"><span style="color:#A0ADA0;--shiki-dark:#758575DD">// 第一种情况：B 是 A 的子类型</span></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> A</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#999999;--shiki-dark:#666666"> {</span><span style="color:#B07D48;--shiki-dark:#BD976A"> a</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">number</span><span style="color:#999999;--shiki-dark:#666666"> };</span></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> B</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#999999;--shiki-dark:#666666"> {</span><span style="color:#B07D48;--shiki-dark:#BD976A"> a</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">number</span><span style="color:#999999;--shiki-dark:#666666">,</span><span style="color:#B07D48;--shiki-dark:#BD976A"> b</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">string</span><span style="color:#999999;--shiki-dark:#666666"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A0ADA0;--shiki-dark:#758575DD">// 第二种情况：A 是 B 的子类型</span></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> A</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#B5695977;--shiki-dark:#C98A7D77"> '</span><span style="color:#B56959;--shiki-dark:#C98A7D">a</span><span style="color:#B5695977;--shiki-dark:#C98A7D77">'</span><span style="color:#999999;--shiki-dark:#666666">;</span></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> B</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#B5695977;--shiki-dark:#C98A7D77"> '</span><span style="color:#B56959;--shiki-dark:#C98A7D">a</span><span style="color:#B5695977;--shiki-dark:#C98A7D77">'</span><span style="color:#999999;--shiki-dark:#666666"> |</span><span style="color:#B5695977;--shiki-dark:#C98A7D77"> '</span><span style="color:#B56959;--shiki-dark:#C98A7D">b</span><span style="color:#B5695977;--shiki-dark:#C98A7D77">'</span><span style="color:#999999;--shiki-dark:#666666">;</span></span></code></pre>
<p>好像看起来更抽象了：为什么同样是 <code>B</code> 的范围看起来比 <code>A</code> 更广，但是一种情况下 <code>B</code> 是 <code>A</code> 的子类型，另一种情况下 <code>A</code> 是 <code>B</code> 的子类型呢？</p>
<p>一方面可以用最基本的 <code>assignable to</code> 概念判断。第一种情况中，任何需要 <code>A</code> 类型的地方都可以用 <code>B</code> 类型的值来代替，因为 <code>A</code> 要求具备 <code>a: number</code> 属性，而 <code>B</code> 满足这一要求。第二种情况同理判断任何需要 <code>B</code> 类型的地方都可以用 <code>A</code> 类型的值来代替。</p>
<p>另一方面，我们也可以用集合的观点来看待问题。第二种情况此时就变得非常显然了，<code>type B = A | 'b'</code>，这是集合的并运算，所以 <code>A</code> 是 <code>B</code> 的子集（子类型）。问题是怎么理解第一种情况中 <code>B</code> 是 <code>A</code> 的子集（子类型）呢？我们重新表示第一种情况的代码：</p>
<pre class="shiki shiki-themes vitesse-light vitesse-dark" style="background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee" tabindex="0"><code class="language-typescript"><span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> A</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#999999;--shiki-dark:#666666"> {</span></span>
<span class="line"><span style="color:#B07D48;--shiki-dark:#BD976A">  a</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">number</span><span style="color:#999999;--shiki-dark:#666666">;</span></span>
<span class="line"><span style="color:#B07D48;--shiki-dark:#BD976A">  b</span><span style="color:#AB5959;--shiki-dark:#CB7676">?</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">any</span><span style="color:#999999;--shiki-dark:#666666">;</span></span>
<span class="line"><span style="color:#B07D48;--shiki-dark:#BD976A">  c</span><span style="color:#AB5959;--shiki-dark:#CB7676">?</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">any</span><span style="color:#999999;--shiki-dark:#666666">;</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">  [</span><span style="color:#B07D48;--shiki-dark:#BD976A">any_string_here</span><span style="color:#999999;--shiki-dark:#666666">]</span><span style="color:#AB5959;--shiki-dark:#CB7676">?</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">any</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">  ...</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> B</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#999999;--shiki-dark:#666666"> {</span></span>
<span class="line"><span style="color:#B07D48;--shiki-dark:#BD976A">  a</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">number</span><span style="color:#999999;--shiki-dark:#666666">;</span></span>
<span class="line"><span style="color:#B07D48;--shiki-dark:#BD976A">  b</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">string</span><span style="color:#999999;--shiki-dark:#666666">;</span></span>
<span class="line"><span style="color:#B07D48;--shiki-dark:#BD976A">  c</span><span style="color:#AB5959;--shiki-dark:#CB7676">?</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">any</span><span style="color:#999999;--shiki-dark:#666666">;</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">  [</span><span style="color:#B07D48;--shiki-dark:#BD976A">any_string_here</span><span style="color:#999999;--shiki-dark:#666666">]</span><span style="color:#AB5959;--shiki-dark:#CB7676">?</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">any</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">  ...</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">}</span></span></code></pre>
<p>注意 TypeScript/JavaScript 的结构体本身是一个对象，所以其实隐含了所有其他未被注明的属性都是可选的。这么一看，<code>B</code> 可取值集合显然是 <code>A</code> 的子集了，因为 <code>A</code> 没有对 <code>b</code> 属性做出要求：<code>A</code> 的可取值相当于 <code>[number, any, any, ...]</code>，而 <code>B</code> 的可取值相当于 <code>[number, string, any, ...]</code>。可以想象，不同结构类型的 Intersection 运算就是将所有注明的属性取交集，所得结果也会是任意原来类型的子类型。到这里，上文遗留的第二个问题已经解决了。</p>
<h3 id="unknown%2C-never%2C-void" tabindex="-1">unknown, never, void</h3>
<p>理解了类型和集合的对应之后，我们终于可以解决遗留的第一个问题，开始讨论 TypeScript 中的 <code>unknown</code> 和 <code>never</code> 了。</p>
<ul>
<li>空集是所有集合的子集。对应 <code>never</code> 是所有类型的子类型。因此 <code>never</code> 又叫底类型。</li>
<li>任何类型都是 <code>unknown</code> 的子类型，因此 <code>unknown</code> 又叫顶类型。</li>
</ul>
<p><code>unknown</code> 类型相当于没有任何约束，任何值都是 <code>unknown</code> 类型。所以，在我们对插件一无所知的时候，可以使用 <code>APlayer&lt;unknown&gt;</code> 类型。随着增加新的插件 <code>Plugin&lt;P&gt;</code>，我们会有 <code>APlayer&lt;unknown &amp; P&gt; = APlayer&lt;P&gt;</code>（<code>unknown &amp; P = P</code> 是顶类型，或者说全集具有的性质）。</p>
<p>从集合的角度，我们还可以发现，空集的大小为 0，所以 <code>never</code> 没有实例。因此，它可以表示一个函数永远不会返回值（死循环或异常），或者一个变量永远不会被赋值。</p>
<pre class="shiki shiki-themes vitesse-light vitesse-dark" style="background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee" tabindex="0"><code class="language-typescript"><span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">let </span><span style="color:#B07D48;--shiki-dark:#BD976A">bar</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">never</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#999999;--shiki-dark:#666666"> (()</span><span style="color:#999999;--shiki-dark:#666666"> =></span><span style="color:#999999;--shiki-dark:#666666"> {</span></span>
<span class="line"><span style="color:#1E754F;--shiki-dark:#4D9375">  throw</span><span style="color:#AB5959;--shiki-dark:#CB7676"> new </span><span style="color:#59873A;--shiki-dark:#80A665">Error</span><span style="color:#999999;--shiki-dark:#666666">(</span><span style="color:#B5695977;--shiki-dark:#C98A7D77">'</span><span style="color:#B56959;--shiki-dark:#C98A7D">Throw my hands in the air like I just dont care</span><span style="color:#B5695977;--shiki-dark:#C98A7D77">'</span><span style="color:#999999;--shiki-dark:#666666">);</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">})();</span></span></code></pre>
<p>一个函数除了正常情况（有特定返回值）和永远不返回（<code>never</code>）之外，还可能我们并不关心它的返回值。通常这可以通过什么都不返回实现（其实是返回 <code>undefined</code>）。</p>
<pre class="shiki shiki-themes vitesse-light vitesse-dark" style="background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee" tabindex="0"><code class="language-typescript"><span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> f</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#999999;--shiki-dark:#666666"> ()</span><span style="color:#999999;--shiki-dark:#666666"> =></span><span style="color:#2E8F82;--shiki-dark:#5DA994"> void</span><span style="color:#999999;--shiki-dark:#666666">;</span></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">let </span><span style="color:#59873A;--shiki-dark:#80A665">a</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">f</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#999999;--shiki-dark:#666666"> ()</span><span style="color:#999999;--shiki-dark:#666666"> =></span><span style="color:#999999;--shiki-dark:#666666"> {};</span></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">let </span><span style="color:#59873A;--shiki-dark:#80A665">b</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">f</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#999999;--shiki-dark:#666666"> ()</span><span style="color:#999999;--shiki-dark:#666666"> =></span><span style="color:#2F798A;--shiki-dark:#4C9A91"> 1</span><span style="color:#999999;--shiki-dark:#666666">;</span></span></code></pre>
<p>注意不关心（不使用）返回值不等于没有返回值。这就是 <code>void</code> 类型的特殊性，在一个标注为需要返回值 <code>void</code> 的函数的地方，我们使用返回值为任意值的函数都是可以的（如上面的 <code>b</code>）。</p>
