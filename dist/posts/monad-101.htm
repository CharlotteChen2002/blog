<p>一份 Monad cheat sheet.</p>
<blockquote>
<p>以前在别人的一篇 blog 里看到过有这样一句话，大意是：关于 monad，几乎每个在学习函数式编程中接触到这个模式的，都会写一篇博客描述他的理解。而且不同的人对 monad 的理解有所不同（暗讽 monad 的复杂）。</p>
</blockquote>
<p>所以咱也来写一份！尽管 Monad（单子）是一个来源于范畴论的概念（在范畴论中它被定义为「自函子范畴上的幺半群」），若没有接触过范畴论可能会觉得这份定义很难理解，然而在实际编程中，我们只需要数行代码就可以构造出「幺半群」、「函子」和「单子」。</p>
<p>本文将首先用 TypeScript 构造出「幺半群」、「函子」和「单子」及相关示例，然后再（尝试）解释这些概念。因为我们只需要在「程序语言的类型」这一具体语境下使用范畴论的一些概念，所以这里的「范畴论知识」也某种程度上被特化了，我们不会涉及到范畴论中的全部抽象。</p>
<!-- more -->
<p>参考：</p>
<ul>
<li>我所理解的 monad 系列：<a href="http://hongjiang.info/understand-monad-0/" target="_blank" rel="noopener">http://hongjiang.info/understand-monad-0/</a></li>
<li>上文的一个整理版本：<a href="https://chengchaos.github.io/2019/01/08/monads-and-monoids-notes.html" target="_blank" rel="noopener">https://chengchaos.github.io/2019/01/08/monads-and-monoids-notes.html</a></li>
<li>怎么理解“一个单子（Monad）说白了不过就是自函子范畴上的一个幺半群而已”? - chris的回答 - 知乎：<a href="https://www.zhihu.com/question/282666729/answer/508110678" target="_blank" rel="noopener">https://www.zhihu.com/question/282666729/answer/508110678</a></li>
<li>十分钟魔法练习 - 玩火：<a href="https://magic.huohuo.moe/" target="_blank" rel="noopener">https://magic.huohuo.moe/</a></li>
</ul>
<h2 id="%E5%B9%BA%E5%8D%8A%E7%BE%A4%EF%BC%88monoid%EF%BC%89" tabindex="-1">幺半群（Monoid）</h2>
<p>幺半群是一个代数结构。不过我们这里不直接介绍代数结构的概念，而是用代码来说明。</p>
<pre class="shiki shiki-themes vitesse-light vitesse-dark" style="background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee" tabindex="0"><code class="language-typescript"><span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">function</span><span style="color:#59873A;--shiki-dark:#80A665"> Product</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">>(</span><span style="color:#B07D48;--shiki-dark:#BD976A">x</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">,</span><span style="color:#B07D48;--shiki-dark:#BD976A"> y</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">)</span><span style="color:#999999;--shiki-dark:#666666"> {</span></span>
<span class="line"><span style="color:#A0ADA0;--shiki-dark:#758575DD">  // 具体实现</span></span>
<span class="line"><span style="color:#1E754F;--shiki-dark:#4D9375">  return</span><span style="color:#B07D48;--shiki-dark:#BD976A"> x</span><span style="color:#AB5959;--shiki-dark:#CB7676"> *</span><span style="color:#B07D48;--shiki-dark:#BD976A"> y</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">}</span></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">function</span><span style="color:#59873A;--shiki-dark:#80A665"> getIdentityElement</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">>():</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> T</span><span style="color:#999999;--shiki-dark:#666666"> {</span></span>
<span class="line"><span style="color:#A0ADA0;--shiki-dark:#758575DD">  // 具体实现</span></span>
<span class="line"><span style="color:#1E754F;--shiki-dark:#4D9375">  return</span><span style="color:#2F798A;--shiki-dark:#4C9A91"> 1</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">}</span></span></code></pre>
<p>在这里，<code>Product</code> 是一个「二元运算」，<code>getIdentityElement</code> 是返回一个「单位元素」。幺半群要求这个二元运算满足结合律，即 <code>(a * b) * c = a * (b * c)</code>，并且单位元素满足 <code>a * 1 = 1 * a = a</code>。</p>
<blockquote>
<p><code>Monoid&lt;T&gt;</code>?</p>
<p>读者在别的地方可能会看到幺半群的另一种实现：通过 <code>Monoid&lt;T&gt;</code> 定义一个类，然后给它定义一个 <code>concat</code> 方法以实现二元运算。然而类的属性调用毕竟只是一个语法糖，考虑到引入额外的类/对象可能会增加理解的难度，这里我们直接定义了一个函数 <code>Product</code>。</p>
</blockquote>
<p>乘法运算显然是满足结合律且具备单位元素的。同理，自然数集上的加法运算、字符串的拼接等都是幺半群。所以我们可以替换 <code>Product</code> 和 <code>getIdentityElement</code> 的内部实现：</p>
<pre class="shiki shiki-themes vitesse-light vitesse-dark" style="background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee" tabindex="0"><code class="language-typescript"><span class="line"><span style="color:#A0ADA0;--shiki-dark:#758575DD">// 加法</span></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">function</span><span style="color:#59873A;--shiki-dark:#80A665"> Product</span><span style="color:#999999;--shiki-dark:#666666">(</span><span style="color:#B07D48;--shiki-dark:#BD976A">x</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">number</span><span style="color:#999999;--shiki-dark:#666666">,</span><span style="color:#B07D48;--shiki-dark:#BD976A"> y</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">number</span><span style="color:#999999;--shiki-dark:#666666">)</span><span style="color:#999999;--shiki-dark:#666666"> {</span></span>
<span class="line"><span style="color:#1E754F;--shiki-dark:#4D9375">  return</span><span style="color:#B07D48;--shiki-dark:#BD976A"> x</span><span style="color:#AB5959;--shiki-dark:#CB7676"> +</span><span style="color:#B07D48;--shiki-dark:#BD976A"> y</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">function</span><span style="color:#59873A;--shiki-dark:#80A665"> getIdentityElement</span><span style="color:#999999;--shiki-dark:#666666">()</span><span style="color:#999999;--shiki-dark:#666666"> {</span></span>
<span class="line"><span style="color:#1E754F;--shiki-dark:#4D9375">  return</span><span style="color:#2F798A;--shiki-dark:#4C9A91"> 0</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A0ADA0;--shiki-dark:#758575DD">// 字符串拼接</span></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">function</span><span style="color:#59873A;--shiki-dark:#80A665"> Product</span><span style="color:#999999;--shiki-dark:#666666">(</span><span style="color:#B07D48;--shiki-dark:#BD976A">x</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">string</span><span style="color:#999999;--shiki-dark:#666666">,</span><span style="color:#B07D48;--shiki-dark:#BD976A"> y</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">string</span><span style="color:#999999;--shiki-dark:#666666">)</span><span style="color:#999999;--shiki-dark:#666666"> {</span></span>
<span class="line"><span style="color:#1E754F;--shiki-dark:#4D9375">  return</span><span style="color:#B07D48;--shiki-dark:#BD976A"> x</span><span style="color:#AB5959;--shiki-dark:#CB7676"> +</span><span style="color:#B07D48;--shiki-dark:#BD976A"> y</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">function</span><span style="color:#59873A;--shiki-dark:#80A665"> getIdentityElement</span><span style="color:#999999;--shiki-dark:#666666">()</span><span style="color:#999999;--shiki-dark:#666666"> {</span></span>
<span class="line"><span style="color:#1E754F;--shiki-dark:#4D9375">  return</span><span style="color:#B5695977;--shiki-dark:#C98A7D77"> ''</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">}</span></span></code></pre>
<p>要求「二元运算」具备结合性有什么好处呢？读者可能已经知道矩阵的快速幂算法，这个算法的核心就是利用了矩阵乘法的结合性。幺半群的结合性保证了我们可以任意计算问题的子结构，然后将子结构合并。</p>
<p>快速幂算法是一种对 <code>Product</code> 运算的调度，然而更一般地，我们有 <code>reduce</code> 方法表示顺次对一个数组中的元素进行 <code>Product</code> 运算（最平凡的调度方法）：</p>
<pre class="shiki shiki-themes vitesse-light vitesse-dark" style="background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee" tabindex="0"><code class="language-typescript"><span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">function</span><span style="color:#59873A;--shiki-dark:#80A665"> reduce</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">>(</span><span style="color:#B07D48;--shiki-dark:#BD976A">arr</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">[],</span><span style="color:#59873A;--shiki-dark:#80A665"> Product</span><span style="color:#999999;--shiki-dark:#666666">: (</span><span style="color:#B07D48;--shiki-dark:#BD976A">x</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">, </span><span style="color:#B07D48;--shiki-dark:#BD976A">y</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">) => </span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">,</span><span style="color:#B07D48;--shiki-dark:#BD976A"> identityElement</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">):</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> T</span><span style="color:#999999;--shiki-dark:#666666"> {</span></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">  let </span><span style="color:#B07D48;--shiki-dark:#BD976A">result</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#B07D48;--shiki-dark:#BD976A"> identityElement</span></span>
<span class="line"><span style="color:#1E754F;--shiki-dark:#4D9375">  for</span><span style="color:#999999;--shiki-dark:#666666"> (</span><span style="color:#AB5959;--shiki-dark:#CB7676">const </span><span style="color:#B07D48;--shiki-dark:#BD976A">x</span><span style="color:#AB5959;--shiki-dark:#CB7676"> of</span><span style="color:#B07D48;--shiki-dark:#BD976A"> arr</span><span style="color:#999999;--shiki-dark:#666666">)</span><span style="color:#999999;--shiki-dark:#666666"> {</span></span>
<span class="line"><span style="color:#B07D48;--shiki-dark:#BD976A">    result</span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#59873A;--shiki-dark:#80A665"> Product</span><span style="color:#999999;--shiki-dark:#666666">(</span><span style="color:#B07D48;--shiki-dark:#BD976A">result</span><span style="color:#999999;--shiki-dark:#666666">,</span><span style="color:#B07D48;--shiki-dark:#BD976A"> x</span><span style="color:#999999;--shiki-dark:#666666">)</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">  }</span></span>
<span class="line"><span style="color:#1E754F;--shiki-dark:#4D9375">  return</span><span style="color:#B07D48;--shiki-dark:#BD976A"> result</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">}</span></span></code></pre>
<p><code>reduce</code> 函数指出了 <code>identityElement</code> 的重要性：如果数组为空，那么 <code>identityElement</code> 就是 <code>Product</code> 运算的结果。这保证了对任意长度的数组都可以进行 <code>reduce</code> 运算。</p>
<p>稍作拓展也可以用于流的计算，考虑布尔值上的或运算也是一个幺半群，而且只要遇到 <code>true</code> 就可以停止计算，返回 <code>true</code>。因此对于一个 <code>false x false x true x ...</code> 的流，我们可以稍微修改 <code>reduce</code> 函数，使得遇到 <code>true</code> 就直接返回，这就实现了「短路」。</p>
<h2 id="%E5%87%BD%E5%AD%90%EF%BC%88functor%EF%BC%89" tabindex="-1">函子（Functor）</h2>
<blockquote>
<p>参考：《类型论简史》- Trebor<br>
CC BY-NC-SA 4.0 DEED<br>
<a href="https://github.com/Trebor-Huang/history" target="_blank" rel="noopener">https://github.com/Trebor-Huang/history</a></p>
</blockquote>
<p>单子的定义是「自函子范畴上的幺半群」，「范畴」可以简单理解成一个集合，这个集合的每个元素都是一个「对象」。对于每对对象 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></eq> 和 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></eq>，又存在一个集合 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>o</mi><mi>m</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">hom(A, B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span></eq>，可以简单定义成：<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>o</mi><mi>m</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>f</mi><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">hom(A, B) = \{f\ |\ f: A \to B\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">}</span></span></span></span></eq>，即从 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></eq> 到 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></eq> 的所有函数。</p>
<p>换句话来说，「范畴」就是在研究一类对象和它们之间的关系。对于程序语言，「对象」<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></eq>, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></eq> 就是类型 <code>type A; type B</code>，而 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>o</mi><mi>m</mi><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">hom(A, B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span></eq> 就是 <code>type Hom&lt;A, B&gt; = (a: A) =&gt; B</code>，即从 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></eq> 到 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></eq> 的所有函数，又叫 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></eq> 到 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></eq> 的态射。</p>
<p>这么定义有什么好处呢？读者可能已经很熟悉数学上的罗素悖论，即「所有集合的集合」这个概念会引入矛盾。在数学中我们研究的对象往往是分层次的，例如我们会讨论实数 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">r \in \mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span></eq>，而不会讨论 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi><mo>∈</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R} \in \mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.728em;vertical-align:-0.0391em;"></span><span class="mord mathbb">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span></eq>，或者我们可能希望讨论一些实数集合构成的集合族。注意这些数学对象间具备的层次性。事实上，层级混乱的命题也一般没有数学意义。</p>
<p>范畴对讨论的对象的层次进行了限制，（当前）我们讨论的对象，即「类型」，都处于同一层次，都是某个具体的、可以被构造出来的类型，如 <code>int, List&lt;int&gt;, List&lt;List&lt;int&gt;&gt;</code>。之所以要强调这一点，是因为「类型」也可以看成有「类型」，类型的类型一般称为 kind。例如 <code>List</code> 接受一个「具体类型」，输出一个「具体类型」，所以 <code>List</code> 的 kind 是 <code>Type -&gt; Type</code>。限制在「具体类型」这一层后，我们就不必讨论 <code>List</code> 这种高阶类型（HKT, Higher Kinded Type）。</p>
<p>范畴间的映射就是函子。因为我们的语境下只有一个范畴，就是全体「具体类型」为对象的范畴，所以这里的函子都是自函子（自函子就是范畴到自身的映射）。</p>
<p>还是有点抽象，范畴间的映射是什么呢？严格的定义可以参考范畴的交换图，直观理解就是：我们有函数 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></eq>，使得对于每个对象 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></eq>，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></eq> 将 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></eq> 对应到 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span></eq>，并且对于每个 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f: A \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></eq>，我们有 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>:</mo><mi>F</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mi>F</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(f): F(A) \to F(B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span></eq>，即 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></eq> 保持了范畴间的结构。写成代码：</p>
<pre class="shiki shiki-themes vitesse-light vitesse-dark" style="background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee" tabindex="0"><code class="language-typescript"><span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> Hom</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">A</span><span style="color:#999999;--shiki-dark:#666666">,</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> B</span><span style="color:#999999;--shiki-dark:#666666">></span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#999999;--shiki-dark:#666666"> (</span><span style="color:#B07D48;--shiki-dark:#BD976A">a</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">A</span><span style="color:#999999;--shiki-dark:#666666">)</span><span style="color:#999999;--shiki-dark:#666666"> =></span><span style="color:#2E8F82;--shiki-dark:#5DA994"> B</span></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> List</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">></span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> T</span><span style="color:#999999;--shiki-dark:#666666">[]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">function</span><span style="color:#59873A;--shiki-dark:#80A665"> fmap</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">A</span><span style="color:#999999;--shiki-dark:#666666">,</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> B</span><span style="color:#999999;--shiki-dark:#666666">>(</span><span style="color:#B07D48;--shiki-dark:#BD976A">f</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">Hom</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">A</span><span style="color:#999999;--shiki-dark:#666666">, </span><span style="color:#2E8F82;--shiki-dark:#5DA994">B</span><span style="color:#999999;--shiki-dark:#666666">>):</span><span style="color:#999999;--shiki-dark:#666666"> (</span><span style="color:#B07D48;--shiki-dark:#BD976A">list</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">List</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">A</span><span style="color:#999999;--shiki-dark:#666666">>)</span><span style="color:#999999;--shiki-dark:#666666"> =></span><span style="color:#2E8F82;--shiki-dark:#5DA994"> List</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">B</span><span style="color:#999999;--shiki-dark:#666666">></span><span style="color:#999999;--shiki-dark:#666666"> {</span></span>
<span class="line"><span style="color:#1E754F;--shiki-dark:#4D9375">  return</span><span style="color:#999999;--shiki-dark:#666666"> (</span><span style="color:#B07D48;--shiki-dark:#BD976A">list</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">List</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">A</span><span style="color:#999999;--shiki-dark:#666666">>)</span><span style="color:#999999;--shiki-dark:#666666"> =></span><span style="color:#B07D48;--shiki-dark:#BD976A"> list</span><span style="color:#999999;--shiki-dark:#666666">.</span><span style="color:#59873A;--shiki-dark:#80A665">map</span><span style="color:#999999;--shiki-dark:#666666">(</span><span style="color:#B07D48;--shiki-dark:#BD976A">f</span><span style="color:#999999;--shiki-dark:#666666">)</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">}</span></span></code></pre>
<p>回顾两条性质：</p>
<ul>
<li>对于每个对象 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></eq>，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></eq> 将 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span></eq> 对应到 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span></eq>。这里每个 <code>T</code> 对应到 <code>List&lt;T&gt;</code>。</li>
<li>对于每个 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f: A \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></eq>，我们有 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>:</mo><mi>F</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mi>F</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(f): F(A) \to F(B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span></eq>。这里每个 <code>f: A =&gt; B</code> 对应到 <code>fmap(f): List&lt;A&gt; =&gt; List&lt;B&gt;</code>。</li>
</ul>
<p>所以 <code>List</code> 是一个高阶类型，同时也是一个（「具体类型」范畴上的）函子。这就体现出了范畴对层次抽象的好处。</p>
<p>这里我们没有讨论更复杂的类型，如 <code>Map</code>，它接受两个类型参数，不过这可以用柯里化的技巧绕过，这里不再展开。</p>
<h2 id="%E5%8D%95%E5%AD%90%EF%BC%88monad%EF%BC%89" tabindex="-1">单子（Monad）</h2>
<p>现在我们知道幺半群和函子的定义，那么单子是什么呢？单子是一个自函子范畴上的幺半群，即一个函子，同时具备幺半群的性质。</p>
<blockquote>
<p>Haskell 和其他很多编程语言的 monad 具有的基本操作是 bind 和 return，读者可能会发觉 bind 和 return 和本文在构造的东西好像没什么关系，实际上两种定义确实不同。虽然它们是等价的，但为避免混淆，请先忘掉 Haskell 的 bind 和 return 那套。</p>
</blockquote>
<p>在范畴上构建幺半群其实不是很显然。再次注意，范畴讨论的是对象和对象之间的映射。因此，为了引入单位元，我们需要范畴具备一个「终对象」；为了引入乘法，我们需要范畴具备一个「直积」。不过我们可以不用考虑这些通用的「抽象废话」，而是对「自函子」和「幺半群」进行提炼：</p>
<ul>
<li>自函子：<code>List, Set, Maybe, Either</code> 等；</li>
<li>幺半群：运算的结合性、单位元。</li>
</ul>
<p>运算的结合性我们之前写的是：</p>
<pre class="shiki shiki-themes vitesse-light vitesse-dark" style="background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee" tabindex="0"><code class="language-typescript"><span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">function</span><span style="color:#59873A;--shiki-dark:#80A665"> Product</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">>(</span><span style="color:#B07D48;--shiki-dark:#BD976A">x</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">,</span><span style="color:#B07D48;--shiki-dark:#BD976A"> y</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">)</span><span style="color:#999999;--shiki-dark:#666666"> {</span></span>
<span class="line"><span style="color:#1E754F;--shiki-dark:#4D9375">  return</span><span style="color:#B07D48;--shiki-dark:#BD976A"> x</span><span style="color:#AB5959;--shiki-dark:#CB7676"> *</span><span style="color:#B07D48;--shiki-dark:#BD976A"> y</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">}</span></span></code></pre>
<p>函数签名：<code>(x: T, y: T) =&gt; T</code>。</p>
<p>那么要求自函子结合，就是要求某种 <code>Functor F</code>，有一个新的函子由原先函子组合（Product）：<code>(F, F) =&gt; F</code>。在「自函子范畴」上，Product 操作就是自函子的组合。</p>
<p>这里注意，虽然我们之前说 <code>List, Set, Maybe, Either</code> 都是自函子，但我们考虑自函子的组合是取 <code>(F, F) =&gt; F</code> 中的 <code>F</code> 为某个特定的自函子，例如 <code>List</code>，而不是任意两个自函子组合。这样 <code>(F, F) =&gt; F</code> 就是自函子范畴上 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>×</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">F \times F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></eq> 到 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></eq> 的态射。</p>
<p>单位元的定义有些出入。单位元不再是 <code>F</code> 的一个元素，而是 1（范畴的终对象，自函子范畴上就是 identity 函子）到 <code>F</code> 的一个态射。这样再要求一下结合性和单位元乘积的性质（用交换图），我们就在自函子范畴上建立了一个幺半群。</p>
<p>结合函子本身有的 <code>fmap</code> 方法，我们终于可以定义 monad 了：</p>
<pre class="shiki shiki-themes vitesse-light vitesse-dark" style="background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee" tabindex="0"><code class="language-typescript"><span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> Hom</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">A</span><span style="color:#999999;--shiki-dark:#666666">,</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> B</span><span style="color:#999999;--shiki-dark:#666666">></span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#999999;--shiki-dark:#666666"> (</span><span style="color:#B07D48;--shiki-dark:#BD976A">a</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">A</span><span style="color:#999999;--shiki-dark:#666666">)</span><span style="color:#999999;--shiki-dark:#666666"> =></span><span style="color:#2E8F82;--shiki-dark:#5DA994"> B</span></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">type</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> List</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">></span><span style="color:#999999;--shiki-dark:#666666"> =</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> T</span><span style="color:#999999;--shiki-dark:#666666">[]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A0ADA0;--shiki-dark:#758575DD">// 1 到 F 的态射</span></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">function</span><span style="color:#59873A;--shiki-dark:#80A665"> unit</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">>(</span><span style="color:#B07D48;--shiki-dark:#BD976A">x</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">):</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> List</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">></span><span style="color:#999999;--shiki-dark:#666666"> {</span></span>
<span class="line"><span style="color:#1E754F;--shiki-dark:#4D9375">  return</span><span style="color:#999999;--shiki-dark:#666666"> [</span><span style="color:#B07D48;--shiki-dark:#BD976A">x</span><span style="color:#999999;--shiki-dark:#666666">]</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">}</span></span>
<span class="line"><span style="color:#A0ADA0;--shiki-dark:#758575DD">// FxF 到 F 的态射</span></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">function</span><span style="color:#59873A;--shiki-dark:#80A665"> join</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">>(</span><span style="color:#B07D48;--shiki-dark:#BD976A">list</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">List</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">List</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">>>):</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> List</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">T</span><span style="color:#999999;--shiki-dark:#666666">></span><span style="color:#999999;--shiki-dark:#666666"> {</span></span>
<span class="line"><span style="color:#1E754F;--shiki-dark:#4D9375">  return</span><span style="color:#B07D48;--shiki-dark:#BD976A"> list</span><span style="color:#999999;--shiki-dark:#666666">.</span><span style="color:#59873A;--shiki-dark:#80A665">reduce</span><span style="color:#999999;--shiki-dark:#666666">((</span><span style="color:#B07D48;--shiki-dark:#BD976A">acc</span><span style="color:#999999;--shiki-dark:#666666">,</span><span style="color:#B07D48;--shiki-dark:#BD976A"> x</span><span style="color:#999999;--shiki-dark:#666666">)</span><span style="color:#999999;--shiki-dark:#666666"> =></span><span style="color:#B07D48;--shiki-dark:#BD976A"> acc</span><span style="color:#999999;--shiki-dark:#666666">.</span><span style="color:#59873A;--shiki-dark:#80A665">concat</span><span style="color:#999999;--shiki-dark:#666666">(</span><span style="color:#B07D48;--shiki-dark:#BD976A">x</span><span style="color:#999999;--shiki-dark:#666666">),</span><span style="color:#999999;--shiki-dark:#666666"> [])</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">}</span></span>
<span class="line"><span style="color:#A0ADA0;--shiki-dark:#758575DD">// map</span></span>
<span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">function</span><span style="color:#59873A;--shiki-dark:#80A665"> fmap</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">A</span><span style="color:#999999;--shiki-dark:#666666">,</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> B</span><span style="color:#999999;--shiki-dark:#666666">>(</span><span style="color:#B07D48;--shiki-dark:#BD976A">f</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">Hom</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">A</span><span style="color:#999999;--shiki-dark:#666666">, </span><span style="color:#2E8F82;--shiki-dark:#5DA994">B</span><span style="color:#999999;--shiki-dark:#666666">>):</span><span style="color:#999999;--shiki-dark:#666666"> (</span><span style="color:#B07D48;--shiki-dark:#BD976A">list</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">List</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">A</span><span style="color:#999999;--shiki-dark:#666666">>)</span><span style="color:#999999;--shiki-dark:#666666"> =></span><span style="color:#2E8F82;--shiki-dark:#5DA994"> List</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">B</span><span style="color:#999999;--shiki-dark:#666666">></span><span style="color:#999999;--shiki-dark:#666666"> {</span></span>
<span class="line"><span style="color:#1E754F;--shiki-dark:#4D9375">  return</span><span style="color:#999999;--shiki-dark:#666666"> (</span><span style="color:#B07D48;--shiki-dark:#BD976A">list</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">List</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">A</span><span style="color:#999999;--shiki-dark:#666666">>)</span><span style="color:#999999;--shiki-dark:#666666"> =></span><span style="color:#B07D48;--shiki-dark:#BD976A"> list</span><span style="color:#999999;--shiki-dark:#666666">.</span><span style="color:#59873A;--shiki-dark:#80A665">map</span><span style="color:#999999;--shiki-dark:#666666">(</span><span style="color:#B07D48;--shiki-dark:#BD976A">f</span><span style="color:#999999;--shiki-dark:#666666">)</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">}</span></span></code></pre>
<p>上面我们略过了交换图的具体要求。但显然这里的 <code>unit</code> 和 <code>join</code> 操作不是任意的，它们要满足范畴上的幺半群的性质。参考维基百科 - <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)" target="_blank" rel="noopener">Monad</a>：</p>
<pre class="shiki shiki-themes vitesse-light vitesse-dark" style="background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee" tabindex="0"><code class="language-text"><span class="line"><span>(unit ∘ φ) x ↔ ((map φ) ∘ unit) x ↔ x</span></span>
<span class="line"><span>(join ∘ (map join)) mmma ↔ (join ∘ join) mmma ↔ ma</span></span>
<span class="line"><span>(join ∘ (map unit)) ma ↔ (join ∘ unit) ma ↔ ma</span></span>
<span class="line"><span>(join ∘ (map map φ)) mma ↔ ((map φ) ∘ join) mma ↔ mb</span></span></code></pre>
<p>这其实和 Haskell 的 <code>return</code>、<code>bind</code> 表述是等价的。Haskell 的 <code>return</code> 就是 <code>unit</code>，所以我们用 <code>unit</code>, <code>join</code>, <code>fmap</code> 来实现 <code>bind</code>：</p>
<pre class="shiki shiki-themes vitesse-light vitesse-dark" style="background-color:#ffffff;--shiki-dark-bg:#121212;color:#393a34;--shiki-dark:#dbd7caee" tabindex="0"><code class="language-typescript"><span class="line"><span style="color:#AB5959;--shiki-dark:#CB7676">function</span><span style="color:#59873A;--shiki-dark:#80A665"> bind</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">A</span><span style="color:#999999;--shiki-dark:#666666">,</span><span style="color:#2E8F82;--shiki-dark:#5DA994"> B</span><span style="color:#999999;--shiki-dark:#666666">>(</span><span style="color:#B07D48;--shiki-dark:#BD976A">f</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">Hom</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">A</span><span style="color:#999999;--shiki-dark:#666666">, </span><span style="color:#2E8F82;--shiki-dark:#5DA994">List</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">B</span><span style="color:#999999;--shiki-dark:#666666">>>):</span><span style="color:#999999;--shiki-dark:#666666"> (</span><span style="color:#B07D48;--shiki-dark:#BD976A">list</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">List</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">A</span><span style="color:#999999;--shiki-dark:#666666">>)</span><span style="color:#999999;--shiki-dark:#666666"> =></span><span style="color:#2E8F82;--shiki-dark:#5DA994"> List</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">B</span><span style="color:#999999;--shiki-dark:#666666">></span><span style="color:#999999;--shiki-dark:#666666"> {</span></span>
<span class="line"><span style="color:#1E754F;--shiki-dark:#4D9375">  return</span><span style="color:#999999;--shiki-dark:#666666"> (</span><span style="color:#B07D48;--shiki-dark:#BD976A">list</span><span style="color:#999999;--shiki-dark:#666666">: </span><span style="color:#2E8F82;--shiki-dark:#5DA994">List</span><span style="color:#999999;--shiki-dark:#666666">&#x3C;</span><span style="color:#2E8F82;--shiki-dark:#5DA994">A</span><span style="color:#999999;--shiki-dark:#666666">>)</span><span style="color:#999999;--shiki-dark:#666666"> =></span><span style="color:#59873A;--shiki-dark:#80A665"> join</span><span style="color:#999999;--shiki-dark:#666666">(</span><span style="color:#59873A;--shiki-dark:#80A665">fmap</span><span style="color:#999999;--shiki-dark:#666666">(</span><span style="color:#B07D48;--shiki-dark:#BD976A">f</span><span style="color:#999999;--shiki-dark:#666666">)(</span><span style="color:#B07D48;--shiki-dark:#BD976A">list</span><span style="color:#999999;--shiki-dark:#666666">))</span></span>
<span class="line"><span style="color:#999999;--shiki-dark:#666666">}</span></span></code></pre>
<p>可以看出 <code>bind</code> 其实就是更甜的 <code>fmap</code>，它将 <code>List&lt;A&gt;</code> 映射到 <code>List&lt;List&lt;B&gt;&gt;</code>，然后再 <code>join</code>。</p>
